<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>In-Call - VirtuSync</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #17171e;
            color: #d1d1d1;
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        #video-container {
            position: relative;
            width: 80%;
            height: 80%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #000;
            border-radius: 10px;
            overflow: hidden;
        }
        #localVideo {
            width: 200px;
            height: 150px;
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 11;
            object-fit: cover;
            border-radius: 8px;
        }
        #remoteVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 8px;
        }
        .call-timer {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 10px;
            border-radius: 10px;
            font-size: 1.2rem;
        }
        .call-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 20;
        }
        .call-controls button {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background-color: #2b2b3a;
            color: white;
            font-size: 20px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .call-controls button:hover {
            background-color: #3e3e52;
        }
        .call-controls #end-call-btn {
            background-color: #dc3545;
        }
        .call-controls #end-call-btn:hover {
            background-color: #c82333;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <video id="remoteVideo" autoplay playsinline></video>
        <video id="localVideo" autoplay playsinline muted></video>
        <div id="call-timer" class="call-timer">00:00</div>
        <div class="call-controls">
            <button id="toggle-audio-btn"><i class="fa-solid fa-microphone"></i></button>
            <button id="toggle-video-btn"><i class="fa-solid fa-video"></i></button>
            <button id="end-call-btn"><i class="fa-solid fa-phone-slash"></i></button>
        </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const currentUserId = "<%- currentUser.id %>";
        const recipientId = "<%- recipientId %>";
        
        const socket = io({
            query: { userId: currentUserId }
        });

        // --- DOM Elements ---
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const toggleAudioBtn = document.getElementById('toggle-audio-btn');
        const toggleVideoBtn = document.getElementById('toggle-video-btn');
        const endCallBtn = document.getElementById('end-call-btn');
        const callTimerDisplay = document.getElementById('call-timer');

        // --- WebRTC Global State ---
        let localStream;
        let peerConnection;
        let isAudioMuted = false;
        let isVideoMuted = false;
        let callStartTime;
        let callTimerInterval;
        
        // WebRTC configuration with STUN servers
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
            ]
        };
        
        // --- WEBRTC LOGIC ---
        
        const initializePeerConnection = () => {
            peerConnection = new RTCPeerConnection(configuration);
            
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice-candidate', {
                        recipientId: recipientId,
                        candidate: event.candidate,
                    });
                }
            };
            
            peerConnection.ontrack = (event) => {
                remoteVideo.srcObject = event.streams[0];
            };
            
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }
        };
        
        const startCall = async () => {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                
                initializePeerConnection();
                
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                socket.emit('offer', {
                    recipientId: recipientId,
                    offer: peerConnection.localDescription,
                    isAudioOnly: false
                });
                
                startCallTimer();
                console.log('Call started, offer sent.');
            } catch (err) {
                console.error('Error accessing media devices.', err);
            }
        };
        
        // A user visiting this page is assumed to be joining a call
        startCall();

        // --- Socket.IO Event Handlers ---
        socket.on('answer', async (data) => {
            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                console.log('Answer received, connection established.');
            } catch (err) {
                console.error('Error handling answer.', err);
            }
        });
        
        socket.on('ice-candidate', async (data) => {
            try {
                await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                console.log('ICE candidate added.');
            } catch (err) {
                console.error('Error adding ICE candidate.', err);
            }
        });
        
        const endCall = () => {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            localVideo.srcObject = null;
            remoteVideo.srcObject = null;
            stopCallTimer();
            // Send the "Call ended" message
            socket.emit('private-message', { recipientId, message: "Call has been ended." });
            socket.emit('end-call', { recipientId });
            window.location.href = '/profile';
        };
        
        // Call timer functions
        const startCallTimer = () => {
            callStartTime = Date.now();
            callTimerInterval = setInterval(updateCallTimer, 1000);
            callTimerDisplay.style.display = 'block';
        };

        const updateCallTimer = () => {
            const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
            const minutes = Math.floor(elapsed / 60);
            const seconds = elapsed % 60;
            callTimerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        };

        const stopCallTimer = () => {
            clearInterval(callTimerInterval);
            callTimerDisplay.style.display = 'none';
            callTimerDisplay.textContent = '00:00';
        };

        const toggleAudio = () => {
            if (!localStream) return;
            isAudioMuted = !isAudioMuted;
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isAudioMuted;
            });
            toggleAudioBtn.innerHTML = isAudioMuted ? '<i class="fa-solid fa-microphone-slash"></i>' : '<i class="fa-solid fa-microphone"></i>';
        };

        const toggleVideo = () => {
            if (!localStream) return;
            isVideoMuted = !isVideoMuted;
            localStream.getVideoTracks().forEach(track => {
                track.enabled = !isVideoMuted;
            });
            toggleVideoBtn.innerHTML = isVideoMuted ? '<i class="fa-solid fa-video-slash"></i>' : '<i class="fa-solid fa-video"></i>';
        };

        endCallBtn.addEventListener('click', endCall);
        toggleAudioBtn.addEventListener('click', toggleAudio);
        toggleVideoBtn.addEventListener('click', toggleVideo);

        socket.on('end-call', () => {
            endCall();
            alert('Call ended by the other user.');
        });
    </script>
</body>
</html>
